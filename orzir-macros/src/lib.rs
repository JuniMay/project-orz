use cast::{caster_impl, register_caster_impl};
use interfaces::{
    control_flow::derive_control_flow_impl, data_flow::derive_data_flow_impl,
    region_interface::derive_region_interface_impl,
};
use proc_macro::TokenStream;
use ty::derive_ty;

use crate::op::derive_op;

mod cast;
mod interfaces;
mod op;
mod ty;

/// Implement a [Op](orzir_core::Op) for the given struct.
///
/// This will first generate a `new` constructor for the struct, which returns
/// an `ArenaPtr<OpObj>` object.
///
/// The `#[mnemonic = "..."]` attribute is used to specify the mnemonic of the
/// operation. The mnemonic string will be split by the first dot character. The
/// first part will be used as the dialect mnemonic, and the second part will be
/// used as the operation mnemonic.
///
/// The `#[interfaces(...)]` and `#[verifiers(...)]` attributes are used to
/// implement/register the interfaces and verifiers for the operation.
///
/// By specifying the verifiers, the corresponding traits will be implemented
/// automatically. and the trait casters will be registered in the context when
/// calling [`Op::register`](orzir_core::Op::register). Also, the
/// [`VerifyInterfaces`](orzir_core::VerifyInterfaces) trait will be implemented
/// for the operation, by calling all the `verify` function in the verifier
/// traits.
///
/// The registering process of interfaces will also be generated by specifying
/// the `interfaces` attribute. However, they will not be implemented
/// automatically.
///
/// The verifiers can only be implemented when deriving the `Op` trait. But the
/// interfaces can be implemented in a plug-in manner. This can be done by
/// calling the `register_caster` macro in the `register` function of any
/// dialect.
///
/// To make a struct valid for the `Op` derive, the `#[metadata]` attribute must
/// be specified for the metadata field of the struct, which contains the
/// `self_ptr` and `parent_block` fields.
///
/// For entities like results, operands, successors, and regions, the
/// corresponding fields must be specified. There are currently two ways to
/// specify these fields:
///
/// 1. Using the `#[result(n)]`, `#[operand(n)]`, `#[successor(n)]`, and
///   `#[region(n)]` attributes, where `n` is the index of the field.
/// 2. Using the `#[result(...)]`, `#[operand(...)]`, `#[successor(...)]`, and
///   `#[region(...)]` attributes, which means the field is a vector of the
///   corresponding type.
#[proc_macro_derive(
    Op,
    attributes(mnemonic, verifiers, interfaces, metadata, result, operand,)
)]
pub fn op(item: TokenStream) -> TokenStream {
    derive_op(item.into())
        .unwrap_or_else(|err| err.to_compile_error())
        .into()
}

/// Implement a [Ty](orzir_core::Ty) for the given struct.
///
/// This is similar to the [`Op`] derive, but for the `Ty` trait, except that
/// the constructor will be `get` for singleton style construction.
#[proc_macro_derive(Ty, attributes(mnemonic, verifiers, interfaces))]
pub fn ty(item: TokenStream) -> TokenStream { derive_ty(item.into()).unwrap().into() }

/// Create a caster for casting from one trait object to another.
///
/// # Example
///
/// Below is an example of getting the [`Caster`](orzir_core::Caster) for
/// casting from `ModuleOp` to `IsIsolatedFromAbove`.
///
/// ```rust,ignore
/// caster!(ModuleOp => IsIsolatedFromAbove)
/// ```
#[proc_macro]
pub fn caster(input: TokenStream) -> TokenStream { caster_impl(input.into()).unwrap().into() }

/// Register a trait object caster in the context.
///
/// This is used if the interface/trait is not defined in the same crate as the
/// operation/type.
///
/// # Example
///
/// Below is an example of registering the caster from `ModuleOp` to
/// `IsIsolatedFromAbove`.
///
/// ```rust,ignore
/// register_caster!(ctx, ModuleOp => IsIsolatedFromAbove)
/// ```
#[proc_macro]
pub fn register_caster(input: TokenStream) -> TokenStream {
    register_caster_impl(input.into()).unwrap().into()
}

#[proc_macro_derive(RegionInterface, attributes(region))]
pub fn derive_region_interface(item: TokenStream) -> TokenStream {
    derive_region_interface_impl(item.into())
        .unwrap_or_else(|err| err.to_compile_error())
        .into()
}

#[proc_macro_derive(ControlFlow, attributes(successor))]
pub fn derive_control_flow(item: TokenStream) -> TokenStream {
    derive_control_flow_impl(item.into())
        .unwrap_or_else(|err| err.to_compile_error())
        .into()
}

#[proc_macro_derive(DataFlow, attributes(result, operand))]
pub fn derive_data_flow(item: TokenStream) -> TokenStream {
    derive_data_flow_impl(item.into())
        .unwrap_or_else(|err| err.to_compile_error())
        .into()
}
