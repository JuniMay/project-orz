use cast::{caster_impl, register_caster_impl};
use proc_macro::TokenStream;
use ty::derive_ty;

use crate::operation::derive_op;

mod cast;
mod operation;
mod ty;

/// Implement a [Op](orzir_core::Op) for the given struct.
///
/// This will first generate a `new` constructor for the struct, which returns
/// an `ArenaPtr<OpObj>` object.
///
/// To make the target struct valid for deriving, it must have a field with type
/// [`OpBase`](orzir_core::OpBase), and marked with the `#[base]` attribute.
/// This field is used to store the basic operation informations.
///
/// The `#[mnemonic = "..."]` attribute is used to specify the mnemonic of the
/// operation. The mnemonic string will be split by the first dot character. The
/// first part will be used as the dialect mnemonic, and the second part will be
/// used as the operation mnemonic.
///
/// The `#[interfaces(...)]` and `#[verifiers(...)]` attributes are used to
/// implement/register the interfaces and verifiers for the operation.
///
/// By specifying the verifiers, the corresponding traits will be implemented
/// automatically. and the trait casters will be registered in the context when
/// calling [`Op::register`](orzir_core::Op::register). Also, the
/// [`VerifyInterfaces`](orzir_core::VerifyInterfaces) trait will be implemented
/// for the operation, by calling all the `verify` function in the verifier
/// traits.
///
/// The registering process of interfaces will also be generated by specifying
/// the `interfaces` attribute. However, they will not be implemented
/// automatically.
///
/// The verifiers can only be implemented when deriving the `Op` trait. But the
/// interfaces can be implemented in a plug-in manner. This can be done by
/// calling the `register_caster` macro in the `register` function of any
/// dialect.
#[proc_macro_derive(Op, attributes(mnemonic, base, verifiers, interfaces))]
pub fn op(item: TokenStream) -> TokenStream { derive_op(item.into()).unwrap().into() }

/// Implement a [Type](orzir_core::Type) for the given struct.
///
/// This is similar to the [`Op`] derive, but for the `Type` trait, except that
/// the constructor will be `get` for singleton style construction.
#[proc_macro_derive(Type, attributes(mnemonic, verifiers, interfaces))]
pub fn ty(item: TokenStream) -> TokenStream { derive_ty(item.into()).unwrap().into() }

/// Create a caster for casting from one trait object to another.
///
/// # Example
///
/// Below is an example of getting the [`Caster`](orzir_core::Caster) for
/// casting from `ModuleOp` to `IsIsolatedFromAbove`.
///
/// ```rust,ignore
/// caster!(ModuleOp => IsIsolatedFromAbove)
/// ```
#[proc_macro]
pub fn caster(input: TokenStream) -> TokenStream { caster_impl(input.into()).unwrap().into() }

/// Register a trait object caster in the context.
///
/// This is used if the interface/trait is not defined in the same crate as the
/// operation/type.
///
/// # Example
///
/// Below is an example of registering the caster from `ModuleOp` to
/// `IsIsolatedFromAbove`.
///
/// ```rust,ignore
/// register_caster!(ctx, ModuleOp => IsIsolatedFromAbove)
/// ```
#[proc_macro]
pub fn register_caster(input: TokenStream) -> TokenStream {
    register_caster_impl(input.into()).unwrap().into()
}
